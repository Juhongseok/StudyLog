DDD != 객체지향<br>
오늘은 이 선을 잘 나눌 수 있는 것을 목표로 강의를 들어보자!!!!

# DDD란? 어디까지가 DDD인가

DDD는 무조건 만능이야 VS DDD 굳이 써야돼?

사고의 관점이 가장 크고 적용을 한다한들 문제가 바로 해결 되지는 않음<br>

## 객체지향설계

코드를 어떻게 배치하는지 결정하는 설계 방식<br>
코드를 변경했을 때 사이드이펙트가 가장 적도록<br>
기술적인 고민

## DDD

비지니스의 도메인의 요소로 인해 디자인패턴, 리팩토링, 아키텍처를 바라보자는 사상<br>
기술적인 요소가 아닌 비지니스를 바라보는 사고 방식을 주장하는 사상

DDD는 방법론, 프로세스가 아님<br>
DDD는 복잡한 도메인을 다뤄야 하는 소프트웨어 프로젝트에 박차를 가하는 것을 목표로 삼는 `사고방식`, `우선순위의 모음`

# 도메인주도설계 맛보기

## 동작하는 도메인 모델 만들기

### 도메인 모델
사용자가 프로그램을 사용하는 주제 영역 안에서 당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략

**도메인**
사용자가 프로그램을 사용하는 주제 영역<br>
소프트웨어에 담고자 하는 것 (해결하고자 하는 것)

**모델**
당면한 문제를 해결하는 것과 관련된 측면을 추상화하고 중요하지 않은 세부사항은 생략 (단순화 시키기)

### 동작하는

도메인 모델을 기반으로 핵심 설계와 코드 작성<br>
코드가 변경되면 핵심 설계와 도메인 모델도 변경되어야 함

도메인 모델 == 코드<br>
코드가 변경되면 도메인 모델도 변경

### 도메인주도설계 요약

도메인 전문가와 개발자가 잘 협업해서 도메인 모델을 창조하고 코드로 작성, 사용되는 용어를 코드까지 가져오기

## 모델 주도 설계의 빌딩 블록

도메인 계층 : 비지니스 로직에 대한 설계와 구현으로 이루어짐<br>
DDD의 전제 조건은 도메인 구현을 격리하는 것<br>
DDD를 할라면 어떤 아키텍처를 해야한다?? -> X

구현 가능한 도메인 모델을 구성하는 요소드르이 목록
- 도메인을 표현하기 위한 빌딩블록
  - Associtaion, VO, Entity, Service, Module
- 생명주기를 관리하기 위한 빌딩 블록
  - Aggregate, Repository, Factory

**빌딩 블록의 목적**<br>
구현에 대한 가이드를 제공해서 복잡도를 낮추는 것

DDD는 불변식을 만족<br>
수정된 데이터만 DB 반영하면 돼 -> 도메인 관점이 아닌 데이터 중심 관점<br>
불변식(비지니스)을 만족시키는 객체 그룹 단위 -> 애그리게이트

애그리게이트 단위로 레포지토리 생성<br>
복잡성 감소를 위한 ID로 참조

## 애자일과 도메인 주도 설계

애자일? --> 변경에 기민하자, 전체 속도에 기민하자X

일정을 산출 못하고, 한번에 다 못하니 우선 중요한 것 먼저 만들고 반복적으로 진행하며 시스템을 키워나가기, 피드백을 통한 수정 회고 진행<br>
한번에 다 하지 말고 리팩토링 하자

## 전략적 설계
여러 도메인 모델!!

### 단일 도메인 모델 단점
- 기능 추가와 코드 수정시 충돌
- 사이드이펙트
- 언어의 모호함

복잡해지면서 각 팀의 도메인 모델을 분리해야 함<br>
--> 바운디드 컨텍스트 (우리팀의 상품과 타 팀의 상품은 다른 것)

### 컨텍스트 맵
컨텍스트 사이의 관계와 모델 변환 방식 정의<br>
API 정하고 스펙 정하는 것과 같음

**그럼 누가 관리를 할 것 인지?!?**
--> 전략적 디스틸레이션 (한 곳에 집중!)

도메인 < 서브도메인 + 코어도메인 + 제네릭 서브도메인 + 지원 서브도메인

## 이후 DDD
전술적 패턴 + 전략적 패턴으로 용어가 생기고 정리가 됨

### 트랜잭션 당 하나의 애그리게이트
그러면 타 애그리게이트 싱크를 맞출려면??<br>
--> 도메인 이벤트 사용

이벤트 소싱

### 책임이 과도해진 모델
도메인 모델은 수정이 기준으로 만들어짐<br>
query, Command 단위로 분리

DDD를 할라면 헥사고날을 사용해야하나??? -> X<br>
분리하기 위한 방식 중 하나
