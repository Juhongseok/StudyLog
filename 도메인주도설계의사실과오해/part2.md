# MDD
모델과 핵심 설계는 서로 영향을 주며 변경이 된다

도메인 모델 == 코드

# 빌딩블록
1. 도메인을 표현하기 위한 빌딩 블록
2. 생명주기를 관리하기 위한 빌등 블록

## 도메인 모델
도메인의 개념을 옮기기 위한 직관적인 가이드

# DDD에서의 기능 구현
기능 요구사항과 불변식(상태 변경 시 만족해야하는 조건칙, 언제나 일관되게 유지돼야하는 비지니스 규칙)을 애그리게이트로 구현

엔티티와 값객체는 내가 선택하는 것, 정해진 것은 없음<br>
엔티티 <-> 값객체

## 엔티티
객체의 속성이 아닌 연속성과 식별성(식별자)이 이어지는지 기준으로 정의<br>
수많은 것들 사이에서 특정지어서 찾을 수 있는 것<br>
식별자 동일성

모든 상태변경을 엔티티에서 진행 --> 단순하게 설계된 엔티티만 이해하면 됨

## 값객체
식별성 없는 객체, 속성을 묘사<br>
식별할 필요 없는 객체, 속성만을 관심, 불변성<br>
엔티티의 복잡성을 낮추기 위해 추후 파생되는 객체<br>
속성의 동등성

엔티티의 속성을 표현하기 위해 사용, 값을 고차원적으로 표현을 원할 때<br>
같이 돌아다니는 속성들을 하나로 묶어서 VO로 생성

### 불변의 장점
추후 트래킹할 때 편함<br>
파급효과 발생 없음

# 연관관계와 애그리게이트
## 애그리게이트
엔티티와 값객체를 단순화하기 위해 범위를 지정하는 것<br>
트랜잭션과 데이터 저장/조회의 단위

객체 별 불변식, 통합 불변식

여러 객체가 묶여서 하나의 불변식을 지켜야된다 -> 애그리게이트로 묶어서 사용<br>
모델 내의 참조에 대한 캡슐화를 추상화<br>
데이터 변경의 단위로 다루는 연관객체의 클러스터

**목적** : 내부 아무 객체나 접근해서 수정 막기, 루트 객체를 통해서만 내부 객체 접근<br>
--> 하나의 루트 객체에서 컨트롤하다보니 객체가 커짐

### 루트
무조건 엔티티로 구성<br>
나머지 내부는 엔티티, 값객체 상관 없음

1. 전역식별성
   - 외부에서 직접 접근하기 위해 전역적으로 구분 가능한 식별자
2. 지역식별성
   - 애그리게이트 루트에 의해서만 접근, 내부에서만 구분 가능한 식별자 부여

### 리포지토리
객체 단위가 아닌 애그리게이트 단위로 추가<br>
검색과 연관을 알맞게 조합하면 설계를 이해하기 쉬움

애그리게이트 - 애그리게이트는 결합을 높일 필요 없음(검색, 식별자를 통한 참조)
애그리게이트 내부는 객체 참조를 통해 탐색

### 연관관계
모델 내의 객체를 탐색가능한 관계

애그리게이트 간 관계 맺을 시 지킬 것(애그리게이트 내부에서는 괜춘)
1. 탐색방향 부여
   - 양방향
   - 단방향
2. 한정자 추가해 다중성 줄이기
   - 1:N보다는 N:1로 (컬렉션 전체를 다 가져오는 거는 한정적)
3. 중요하지 않은 관계  제거

#### 방법
1. 객체참조
2. 제3의 객체(Repository)를 통한 탐색(식별자 참조)

### 경계정하기
기능 구현과 불변식을 고려하여 설계<br>
도메인 룰이 있을 때 같이 확인을 해야하는 것을 하나의 경계로 정해서 관리<br>
경계와 경계가 만나는 것이 루트

### 팩토리와 서비스
#### 팩토리
어떤 객체나 전체 애그리게이트를 생성하는 일이 복잡해지거나 내부 구조를 너무 많이 드러나는 경우 팩토리 사용하여 캡슐화 제공

팩토리를 별도의 클래스(객체)라고 생각하는 것이 아니라 하나의 역할로 생각<br>
의존성이 커질 경우 독립적인 팩토리 추가

#### 서비스
어떤 객체에도 속하지 않은 연산

여러 애그리게이트를 처리해야 할 경우

1. 애플리케이션 서비스
2. **도메인 서비스**

## 기타
트랜잭션당 하나의 애그리게이트

여러 애그리게이트재하나에 걸쳐 존재하는 규칙이 언제나 최신상태를 유지하지는 않음<br>
이벤트, 배치, 다른 갱신 매커니즘을 통해 특정시간에 처리(Eventualy Consistency)

