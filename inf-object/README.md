# GRASP

## 정보전문가 (Information Expert)
가장 일반적이고 보편적인 패턴

- 문제
  - 책임을 객체에게 할당하는 일반적인 원칙은?
- 해결방법
  - 책임을 수행하는데 필요한 정보를 가장 많이 알고 있는 객체에 할당

### 정보?
데이터가 아닌 **행동!!**<br>
어떤 상태를 수정하거나 질문에 답하는 책임

ex) 학생의 나이는 몇살인가?? -> 학생에게 질문 / 학생이 질문에 답을 할 수 있음<br>
몇몇이 반대를 하더라도 다수가 찬성을 할 수 있는 것으로

그럼 데이터를 어떻게 관리해야하는지?<br>
ex) 나이를 직접 필드로 관리 / 생년월일 필드를 통해 나이를 계산하여 반환 / 학생 나이를 저장하고 있는 외부 객체로부터 가져오기

데이터를 저장/관리하는 방법은 다르지만 외부에 반환하는 결과는 같음

* 행동 선택 -> 객체 선택 -> 데이터 선택<br>
행동을 먼저 결정하면 구현 수정시에도 외부 객체에 영향 X

행동을 가질 객체를 선택하기 애매하다면 목적어에 책임을 할당

## 창조자 (Creator)
생성이라는 문맥에 특화된 정보 전문가 패턴

- 문제
  - 새로운 인스턴스를 생성하는 책임을 어떤 객체에게 할당?
- 해결방법
  - 한가지라도 만족할 경우 A의 인스턴스를 생성할 책임을 B에게 할당
    - B가 A를 포함하거나 참조 (낮은 결합도)
    - B가 A를 기록 (낮은 결합도)
    - B가 A를 긴밀하게 사용 (낮은 결합도)
    - B가 A를 초기화하는 데 필요한 정보를 알고 있음 (정보 전문가)

## 낮은 결합도 (Low Coupling)
- 문제
  - 낮은 의존성 유지, 변경에 따른 영향 줄이면서 재사용성 높이기
- 해결방법
  - 설계의 전체적인 결합돌르 낮게 유지할 수 있도록 책임 할당
  - 가능한 추가적인 결합이 생기지 않도록

## 높은 응집도 (High Cohesion)
- 문제
  - 낮은 의존성 유지, 변경에 따른 영향 줄이면서 재사용성 높이기
- 해결방법
  - 높은 응집도를 유지하도록 책임 할당 

## 다형성 (Polymorphism)
- 문제
  - 타입을 기반으로 유사하지만 서로 다르게 행동할 때
  - 조건문을 사용하지 않고 변한느 행동을 어떻게 처리할 것 인가
- 해결방법
  - 다형적인 메시지(동일한 요청, 타입에 따라 다른 행동, 동일한 결과 반환)를 이용해서 
  - 행동이 변하는 타입들에게 각 행동을 다루기 위해 책임 할당

## 변경 보호 (Protected Variations)
- 문제
  - 요소들의 변화나 불안정한 요소가 다른 요소에 해로운 영향을 미치지 않도록
- 해결방법
  - 변화가 예상되거나 불안정한 지점을 식별
  - 주위에 안정적인 인터페이스 똔느 추상화를 형성하여 책임 할당

## 간접화 (Indirection)
- 문제
  - 직접적인 의존을 피하기 위해 어디에 책임을 할당?
- 해결방법
  - 다른 컴포넌트나 서비스가 직접 의존하지 않도록 중재하는 중간 객체에 책임을 하당
ex) DAO

## 순수한 가공물 (Pure Fabrication)
- 문제
  - 적당한 책임을 가진 클래스를 찾지 못하는 상황이거나 높은 응집도와 낮은 결합도를 위반하고 싶지 않은경우에 누구에게 책임 할당?
- 해결방법
  - 도메인 개념을 표현하지 않는 인위적으로 만든 클래스에 할당<br>
    높은 응집도와 낮은 결합도, 재사용을 지원하기 위해 만들어짐
ex) 서비스 레이어, DAO

## 컨트롤러 (Controller)
- 문제
  - UI 계층을 통해 전달되는 시스템의 오퍼레이션을 전달받고 조정할 최초의 객체는?
- 해결방법
  - 워크플로우를 표현하는 객체에게 책임 할당
ex) 서비스 레이어
 
# 객체지향
- 메시지 : 다른 객체에게 책임 수행을 요청하는 커뮤니케이션 수단 (먼저 선택)
- 메서드 : 메시지를 수신한 타입 별로 책임을 수행하는 방식 (이후 생성)

동적바인딩 : 런타임에 메시지를 처리할 적절한 클래스와 메서드 탐색

## 메시지와 메서드 분리의 장점
- 변경의 파급효과 제어 가능
- 기존 코드 수정 없이 기능 확장 가능
- 표준적인 구조 강제화 가능 (일관적인 설계)

# 의존성
컴파일타임 의존성 : 인터페이스에 의존<br>
런타임 의존성 : 구체 인스턴스에 의존

외부객체가 구체 인스턴스 생성 후 전달 (DI)

## 의존성 주입
컴파일타임 의존성과 런타임 의존성사이의 차이를 해결하기 위해 외부의 객체가 의존하는 객체를 전달하는 방식
