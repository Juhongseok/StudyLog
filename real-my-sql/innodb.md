# InnoDB
레코드 기반 잠금 제공 -> 동시성 처리 가능

## Primary key Clustering
PK 값 기준으로 순서대로 디스크에 저장

Secondary Index는 레코드 주소 대신 PK 값을 논리적 주소로 사용

Clustering 되어 있어 범위 검색에 용이 & 타 보조 인덱스보다 비중이 높게 잡힘

### Clustering vs Non Clustering
Clustering Index: 테이블 당 무조건 1개, PK를 기준으로 생성<br>
NonClustering Index: 여러개 생성 가능

## 외래키 지원
MyISAM에서는 지원하지 않음

InnoDB에서 외래 키는 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고, 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업이 필요하므로 잠금이 여러 테이블로 전파되고, 그로 인해 데드락이 발생할 때가 많다.

이 작업을 일시적으로 멈추면, 레코드 적재나 삭제 등의 일부 작업도 부가적인 체크를 하지 않는다

```sql
mysql> SET foreign_key_checks=OFF; // 외래키 체크 해제

~~~ 작업을 실행한다
mysql> SET foreign_key_checks=ON;
```

## MVCC
레코드 레벨의 트랜잭션을 지원하는 DBMS가 제공하는 기능, 잠금을 사용하지 않고 일관된 읽기를 제공하기 위함 (InnoDB는 Undo Log를 사용해서 구현)

### Undo Log
MySQL이 트랜잭션과 격리 수준을 보장하기 위해 백업해둔 변경 전의 데이터이다.

트랜잭션 보장: 트랜잭션이 롤백되면 변경된 데이터를 백업된 이전 버전으로 복구시킨다.
격리 수준 보장: 특정 커넥션에서 데이터를 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 격리 수준에 맞는 데이터를 반환한다.
트랜잭션의 롤백(rollback) 기능을 지원하기 위해 사용되는 로그

트랜잭션은 여러 개의 연속된 데이터 조작 작업(INSERT, UPDATE, DELETE)으로 구성될 수 있는데,

언두로그에는 각각의 데이터 조작 작업의 역추적 정보가 저장되어 있어, 롤백이 발생할 경우 해당 트랜잭션이 수행한 작업들을 취소하고 이전 상태로 복원할 수 있다.

### Undo Log 작동 방식
1. Insert, Update, Delete 작업 실행되면 커밋 여부와 상관없이 버퍼 풀에 있는 데이터 변경
2. 언두 로그에 변경 전 값을 백업
3. Commit or Rollback
   1. Commit 시 현 상태 유지 (언두 영역을 필요로 하는 트랜잭션 없을 때 삭제 됨)
   2. Rollback 시 버퍼 풀 복구 및 언두 영역 삭제

**DB 성능에 영향 줄 수 있는 상황**
- 트랜잭션이 길어질때
- 대용량 데이터 한번에 처리 할 경우

이유: 언두 로그 데이터가 많아지면 조회 시 변경 전의 데이터를 찾기 위해 언두 영역을 검색해야 하기 때문에 성능상 문제 있을 수 있음

## 잠금없는 일관된 읽기
데이터를 읽을 때 다른 트랜잭션에 의해 잠금을 걸지않고 데이터를 일관되게 읽는 방법

- Insert와 연결되지 않은 순수한 읽기 작업은 타 트랜잭션의 변경 작업과 관계없이 항상 실행
  - Serializable: 읽기 잠금(shared Lock) 걸림
- 특정 사용자가 레코드를 변경하고 아직 커밋을 수행하지 않았더라도 읽기 작업 방해받지 않음
  - 언두 로그 사용

일관된 읽기를 위해 언두로그를 삭제하지 못하고 유지 -> 트랜잭션 시작했으면 가능한 빨리 커밋이나 롤백 진행하여 완료 시키기